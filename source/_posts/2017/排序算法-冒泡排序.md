---
title: 排序算法--冒泡排序
date: 2017-11-08 21:31:41
tags: '数据结构和算法'
categories: '数据结构和算法'
copyright: true
---
[或许你需要对算法的基本概念进行了解，请访问该链接。](https://fanerge.github.io/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5.html)
#	冒泡排序算法定义（Bubble Sort）
它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。
走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。
这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。

#	冒泡排序算法原理
冒泡排序算法的运作如下：
1.	比较相邻的元素。如果第一个比第二个大，就交换他们两个数的位置。
2.	对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。一次比较后，最后的元素应该会是最大的数。
3.	针对所有的元素重复以上的步骤，除了最后一个（因为最后一个已经是最大的了，不需要参与比较）。
4.	持续对剩余未排序的元素重复上面的步骤，直到没有任何一对数字需要比较。

#	冒泡排序算法分析
##	时间复杂度
若数组的初始状态是正序的，一趟扫描即可完成排序。所需的关键字比较次数 C 和记录移动次数 M 均达到最小值。
	C=n-1；M=0；
		
<span>所以，冒泡排序最好的时间复杂度为 O(n)。</span>若初始数组是反序的，需要进行 n-1 趟排序。每趟排序要进行 n-i 次关键字的比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。
	C=n*(n-1)/2 = O(n^2)；M=3n*(n-1)/2 = O(n^2)
<span>所以，冒泡排序最坏的时间复杂度为 O(n^2)。</span>
综上，因此冒泡排序总的平均时间复杂度为  O(n^2)。		
##	冒泡排序算法的稳定性
冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。
所以，如果两个元素相等，我想你是不会再无聊地把他们俩交换一下的；如果两个相等的元素没有相邻，
那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，
所以冒泡排序是一种稳定排序算法。

#	冒泡排序算法描述
```
function bubbleSort(array) {
	let len = array.length, j, arr = array.slice();
	let tempExchangeVal;
	while (len > 0) {
		for (j = 0; j < len - 1; j++) {
			if (arr[j] > arr[j+1]) {
				// 交换两个值
				tempExchangeVal = arr[j];
				arr[j] = arr[j + 1];
				arr[j + 1] = tempExchangeVal;
			}
		}
		len--;
	}
	return arr;
}
const arr = [5, 4, 3, 2, 1];
let arrSorted = bubbleSort(arr);
console.log(arrSorted); // [1, 2, 3, 4, 5]
console.log(arr); // [5, 4, 3, 2, 1];
```
PS：这里在方法中新生成了一个数组，有不可变对象的思想。
	
#	动态展示
![冒泡排序](http://oz5ii8zjo.bkt.clouddn.com/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F)
	[图片来源](http://web.jobbole.com/87968/)，在此表示感谢！

>	参考文档：
[JS-排序详解-冒泡排序](https://www.cnblogs.com/zhouliang/p/6638010.html)
[十大经典排序算法](http://web.jobbole.com/87968/)
[冒泡排序](https://baike.baidu.com/item/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/4602306?fr=aladdin)