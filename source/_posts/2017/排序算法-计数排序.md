---
title: 排序算法-计数排序
date: 2017-11-20 20:15:37
tags: '数据结构和算法'
categories: '数据结构和算法'
copyright: true
---
#	计数排序的基础
定义：计数排序是一个非基于比较的排序算法。它的优势在于在对一定范围内的整数排序时，它的复杂度为Ο(n+k)（其中k是整数的范围），快于任何比较排序算法。[1-2]  当然这是一种牺牲空间换取时间的做法，而且当O(k)>O(n*log(n))的时候其效率反而不如基于比较的排序（基于比较的排序的时间复杂度在理论上的下限是O(n*log(n)), 如归并排序，堆排序）
计数排序对输入的数据有附加的限制条件：
	1、输入的线性表的元素属于有限偏序集S；
	2、设输入的线性表的长度为n，|S|=k（表示集合S中元素的总数目为k），则k=O(n)。	
		
#	计数排序算法思想
计数排序的基本思想是对于给定的输入序列中的每一个元素x，确定该序列中值小于x的元素的个数（此处并非比较各元素的大小，而是通过对元素值的计数和计数值的累加来确定）。一旦有了这个信息，就可以将x直接存放到最终的输出序列的正确位置上。例如，如果输入序列中只有17个元素的值小于x的值，则x可以直接存放在输出序列的第18个位置上。当然，如果有多个元素具有相同的值时，我们不能将这些元素放在输出序列的同一个位置上，因此，上述方案还要作适当的修改。

#	现实计数算法
##	具体算法实现步骤
<1>. 找出待排序的数组中最大和最小的元素；
<2>. 统计数组中每个值为i的元素出现的次数，存入数组C的第i项；
<3>. 对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；
<4>. 反向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去1。
	```
	function countingSort(arr){
		let len = arr.length,
			Result = [], // 保存排序后的数组
			Count = [], // 保存各项出现次数的数组
			min = max = arr[0];
		console.time('计数排序计时');

		// 查找最大、最小值,并将arr数置入Count数组中,统计出现次数
		for(var i = 0; i < len; i++){
			Count[arr[i]] = Count[arr[i]] ? Count[arr[i]] + 1 : 1; // 求各项出现次数
			min = min <= arr[i] ? min : arr[i]; // 求数组最小值
			max = max >= arr[i] ? max : arr[i]; // 求数组最大值
		}

		// 从最小值->最大值,将计数逐项相加
		for(var j = min; j < max; j++){
			Count[j+1] = (Count[j+1]||0)+(Count[j]||0);
		}

		// Count中,下标为arr数值,数据为arr数值出现次数;反向填充数据进入Result数据
		for(var k = len - 1; k >= 0;k--){
			/*Result[位置] = arr数据*/
			Result[Count[arr[k]] - 1] = arr[k];
			/*减少Count数组中保存的计数*/
			Count[arr[k]]--;
			/*显示Result数组每一步详情*/
			console.log(Result);
		}

		console.timeEnd('计数排序计时');
		return Result;
	}
	var arr = [3,44,38,5,47,15,36,26,27,2,46,4,19,50,48];
	console.log(countingSort(arr));
	```
	PS：时间复杂度：T(n) = O(n)
	空间复杂度：S(n) = O(k)
	是否稳定：是
	排序方式：外排序
运行结果为:
[ , , , , , , , , , , , , , 48 ]
[ , , , , , , , , , , , , , 48, 50 ]
[ , , , , , 19, , , , , , , , 48, 50 ]
[ , , 4, , , 19, , , , , , , , 48, 50 ]
[ , , 4, , , 19, , , , , , 46, , 48, 50 ]
[ 2, , 4, , , 19, , , , , , 46, , 48, 50 ]
[ 2, , 4, , , 19, , 27, , , , 46, , 48, 50 ]
[ 2, , 4, , , 19, 26, 27, , , , 46, , 48, 50 ]
[ 2, , 4, , , 19, 26, 27, 36, , , 46, , 48, 50 ]
[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, , 48, 50 ]
[ 2, , 4, , 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]
[ 2, , 4, 5, 15, 19, 26, 27, 36, , , 46, 47, 48, 50 ]
[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, , 46, 47, 48, 50 ]
[ 2, , 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]
[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]
计数排序计时: 16ms
[ 2, 3, 4, 5, 15, 19, 26, 27, 36, 38, 44, 46, 47, 48, 50 ]

#	动图展示
![动态图 | center](http://oz5ii8zjo.bkt.clouddn.com/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F)
	
>	参考文档：
	[基本算法学习(四)之计数排序(JS)](http://hao.jser.com/archive/13600/)
	[计数排序](https://baike.baidu.com/item/%E8%AE%A1%E6%95%B0%E6%8E%92%E5%BA%8F/8518144?fr=aladdin)
	[十大经典排序算法](http://web.jobbole.com/87968/)
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	
	